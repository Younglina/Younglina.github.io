import{_ as a,o as e,c as t,h as i}from"./app.f8544706.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"author":"Younglina","date":"2021-12-01","categories":["源码阅读"],"tags":["学习"]},"headers":[{"level":2,"title":"Make命令","slug":"make命令","link":"#make命令","children":[]},{"level":2,"title":"MakeFile文件","slug":"makefile文件","link":"#makefile文件","children":[{"level":3,"title":"规则","slug":"规则","link":"#规则","children":[]},{"level":3,"title":"实例","slug":"实例","link":"#实例","children":[]},{"level":3,"title":"伪目标(phony target)","slug":"伪目标-phony-target","link":"#伪目标-phony-target","children":[]}]},{"level":2,"title":"make new","slug":"make-new","link":"#make-new","children":[{"level":3,"title":"$@ 自动变量","slug":"自动变量","link":"#自动变量","children":[]},{"level":3,"title":"$(MAKECMDGOALS) 特殊变量","slug":"makecmdgoals-特殊变量","link":"#makecmdgoals-特殊变量","children":[]},{"level":3,"title":"$(filter-out) 反过滤函数","slug":"filter-out-反过滤函数","link":"#filter-out-反过滤函数","children":[]}]},{"level":2,"title":"make new-test zujian 组件","slug":"make-new-test-zujian-组件","link":"#make-new-test-zujian-组件","children":[]}],"relativePath":"write/sourceRead/element-make-new.md","lastUpdated":1662613821000}'),p={name:"write/sourceRead/element-make-new.md"},m=i('<p>在阅读完源码后发现，其主要的工作原理就是通过make new命令提供的组件名，然后通过 file-save进行一系列的文件生成，注意力都被make命令怎么提供组件名吸引过去了</p><h2 id="make命令" tabindex="-1">Make命令 <a class="header-anchor" href="#make命令" aria-hidden="true">#</a></h2><p>为什么能使用make new命令？ make是一个根据指定的Shell命令进行构建的工具，在这里它依赖于MakeFile文件进行构建。 ​</p><h2 id="makefile文件" tabindex="-1">MakeFile文件 <a class="header-anchor" href="#makefile文件" aria-hidden="true">#</a></h2><h3 id="规则" tabindex="-1">规则 <a class="header-anchor" href="#规则" aria-hidden="true">#</a></h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下: target : prerequisites<br> [tab] commands 上面第一行冒号前面的部分，叫做&quot;目标&quot;（target），冒号后面的部分叫做&quot;前置条件&quot;（prerequisites）； 第二行必须由一个tab键起首，后面跟着&quot;命令&quot;（commands）。 &quot;目标&quot;是必需的，不可省略；&quot;前置条件&quot;和&quot;命令&quot;都是可选的，但是两者之中必须至少存在一个。</p><h3 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-hidden="true">#</a></h3><p>dist: install npm run dist 所以在使用make dist时，dist作为target，前置条件是install，这时候就会执行 install: npm install 在执行完npm install命令之后再回头执行npm run dist</p><h3 id="伪目标-phony-target" tabindex="-1">伪目标(phony target) <a class="header-anchor" href="#伪目标-phony-target" aria-hidden="true">#</a></h3><p>第一行 .PHONY: dist test 这又是什么呢？ 上面说的target通常是文件名， 指明这条规则需要构建的对象，目标可以是一个或者多个文件名， 之间用空格隔开。但是有时候也可以是具体的操作名称，这时候它就是个phony target。</p><p>在注释掉的情况下 <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638262083135-cc0a5d59-683d-42dd-a55b-264bfd947039.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=21&amp;id=u53a71bfa&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=21&amp;originWidth=225&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=5625&amp;status=done&amp;style=none&amp;taskId=u04ac8e46-1b97-4e9a-8d7d-1822a6e1f82&amp;title=&amp;width=225" alt="image.png"> 在这里如果我们使用make test <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638262116914-dce92289-3627-4651-a5e3-f9a660b1c874.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=34&amp;id=ud5e7800e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=34&amp;originWidth=222&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=7425&amp;status=done&amp;style=none&amp;taskId=u76f05dd9-9edd-4719-91c7-c1211f7c5fb&amp;title=&amp;width=222" alt="image.png"> 因为项目中已经存在test文件夹，所以这个命令不会执行，直接跳过 <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638262224868-333e22c6-a041-415d-898a-e3a4ea29f611.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=127&amp;id=u914dab96&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=127&amp;originWidth=275&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11037&amp;status=done&amp;style=none&amp;taskId=u98c4d62e-d9e0-4e5e-8beb-0904406a347&amp;title=&amp;width=275" alt="image.png"> 所以在知道可能会存在命令与文件同名的情况下，将命令显示的声明未伪目标，这样每次执行的时候就不会去检查是否存在同名文件，而是直接执行命令 ​</p><h2 id="make-new" tabindex="-1">make new <a class="header-anchor" href="#make-new" aria-hidden="true">#</a></h2><p>在使用make new zujian 组件时，具体是执行了下面的命令： new: node build/bin/new.js $(filter-out $@,$(MAKECMDGOALS)) 这里一个个分析$@，$(MAKECMDGOALS)，$(filter-out)的作用 新建一个new-test.js <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638263381407-10c5da2a-b36c-4022-b658-7ec7469d4857.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=465&amp;id=u70d6b996&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=465&amp;originWidth=677&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=65839&amp;status=done&amp;style=none&amp;taskId=u796840f9-692a-451c-877d-1a900611f90&amp;title=&amp;width=677" alt="image.png"></p><h3 id="自动变量" tabindex="-1">$@ 自动变量 <a class="header-anchor" href="#自动变量" aria-hidden="true">#</a></h3><p>在makefile文件中新增一行命令，然后执行make new-test zujian 组件 <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638263588379-ac24c203-eec9-4265-826a-b8513f3feffe.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=211&amp;id=u4e1f5714&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=564&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=34581&amp;status=done&amp;style=none&amp;taskId=u83c878b9-64a1-4c88-b145-3b475e21180&amp;title=&amp;width=564" alt="image.png"> 可以发现$@就是对应所执行的目标new-test</p><h3 id="makecmdgoals-特殊变量" tabindex="-1">$(MAKECMDGOALS) 特殊变量 <a class="header-anchor" href="#makecmdgoals-特殊变量" aria-hidden="true">#</a></h3><p>同上操作 <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638263741391-f20892bc-300a-488b-84bc-3d40de11fbbd.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=237&amp;id=ufa3f813b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=237&amp;originWidth=583&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40049&amp;status=done&amp;style=none&amp;taskId=u29a0402e-42ca-41e2-a0fd-68e8cee6668&amp;title=&amp;width=583" alt="image.png"> make 在执行时，会设置一个特殊的变量 MAKECMDGOALS，该变量记录了命令行参数指定的目标列表 通过$(MAKECMDGOALS)就能获取make后面的参数</p><h3 id="filter-out-反过滤函数" tabindex="-1">$(filter-out) 反过滤函数 <a class="header-anchor" href="#filter-out-反过滤函数" aria-hidden="true">#</a></h3><p>使用时的格式$(filter-out PATTERN…,TEXT)，在js中应该都使用过filter去过滤数组，返回的是符合条件的数据，这里的filter-out意思就是过滤掉字串“TEXT”中所有符合模式“PATTERN”的，保留所有不符合此模式的。 返回值 ：空格分割的“TEXT”字串中所有不符合模式“PATTERN”的字串。 例如： <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638264363362-444b9b84-6cdb-47a3-9103-45ddd3c8db0f.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=169&amp;id=u3b73903e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=169&amp;originWidth=439&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=28794&amp;status=done&amp;style=none&amp;taskId=u27a493c6-e3de-4e89-85d7-308cf807912&amp;title=&amp;width=439" alt="image.png"></p><h2 id="make-new-test-zujian-组件" tabindex="-1">make new-test zujian 组件 <a class="header-anchor" href="#make-new-test-zujian-组件" aria-hidden="true">#</a></h2><p>所以在执行make new-test zujian 组件时 new: node build/bin/new.js $(filter-out $@,$(MAKECMDGOALS)) 在new.js中通过process.argv所获取到的参数就是从 $(MAKECMDGOALS)对应的new-test zujian 组件这三个目标列表中过滤掉 $@对应的new-test，就是我们需要的英文名和中文名 const componentname=process.argv[2]; const chineseName=process.argv[3] || componentname; <img src="https://cdn.nlark.com/yuque/0/2021/png/191608/1638264887133-0b58d012-fc9e-4acc-8a3c-3d0992074414.png#clientId=u58d5d4f9-bfb8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=217&amp;id=u0eb2e750&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=217&amp;originWidth=584&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=40482&amp;status=done&amp;style=none&amp;taskId=ufccfe0a8-7392-40ee-b67a-4f35758d635&amp;title=&amp;width=584" alt="image.png"></p>',21),n=[m];function r(o,d,l,s,c,h){return e(),t("div",null,n)}const f=a(p,[["render",r]]);export{u as __pageData,f as default};
